# VSA + DDD Implementation Plan *with Repository Pattern* for **CertQuiz**

## 1 — Overview

This plan describes how to rebuild **CertQuiz** using **Vertical Slice Architecture (VSA)** and **Domain‑Driven Design (DDD)** while **retaining a thin Repository pattern** for persistence isolation. The migration is a **clean‑slate rewrite**; legacy code will be preserved in a separate branch but not evolved further.

---

## 2 — Current State Snapshot

| Area             | Status                                                                        |
| ---------------- | ----------------------------------------------------------------------------- |
| **Database**     | PostgreSQL + Drizzle ORM (schema & data already in place)                     |
| **Tables**       | 18 tables across 5 bounded contexts (User, Quiz, Question, Community, System) |
| **Codebase**     | Module‑based architecture (to be removed)                                     |
| **Type Exports** | Row types generated by Drizzle (used for mapping)                             |

---

## 3 — High‑Level Goals

1. **Vertical slices first‑class** – each user journey lives in one folder.
2. **Rich domain model** – Entities, Value Objects, Aggregates protected by Repositories.
3. **Single‑model (No explicit CQRS)** – read & write share the same domain types for now.
4. **Transactional consistency** – one HTTP request = one DB transaction.
5. **90% code coverage inside the domain layer, ≥80% overall**.

---

## 4 — Implementation Strategy

### 4.1 Clean‑Slate Reset

```bash
# keep a backup branch
git checkout -b legacy-module-arch
# main branch: start fresh
rm -rf apps/api/src/{modules,services,repositories}
```

### 4.2 New Directory Structure

```
apps/api/src/
├── features/                # Vertical slices
│   ├── quiz/
│   │   ├── start-quiz/
│   │   │   ├── handler.ts          # Application logic
│   │   │   ├── handler.test.ts
│   │   │   ├── dto.ts              # Command/Query DTOs
│   │   │   ├── validation.ts       # Zod schemas
│   │   │   └── route.ts            # Hono route
│   │   ├── submit-answer/
│   │   └── get-results/
│   │   └── domain/                 # Domain model (quiz BC)
│   │       ├── aggregates/
│   │       │   └── QuizSession.ts
│   │       ├── entities/
│   │       │   ├── Quiz.ts
│   │       │   └── Question.ts
│   │       ├── value-objects/
│   │       │   ├── QuizId.ts
│   │       │   └── Score.ts
│   │       └── repositories/
│   │           ├── IQuizRepository.ts   # Interface (domain layer)
│   │           └── DrizzleQuizRepository.ts # Implementation (infrastructure detail)
│   ├── user/
│   ├── auth/
│   └── question/
├── infra/
│   ├── db/
│   │   ├── client.ts        # postgres -> drizzle wrapper
│   │   └── migrations/
│   ├── unit-of-work.ts      # Transaction helper (one‑liner alias)
│   └── events/              # Domain event dispatcher
├── system/
│   └── health/
└── shared/
    ├── errors.ts
    ├── result.ts
    └── types.ts
```

* **Repository interface** lives **inside the domain** (`features/quiz/domain/repositories`) because it is part of the ubiquitous language.
* **Concrete Drizzle implementation** lives one level down the same BC folder so slices can import it directly (VSA encourages penetrable walls inside a slice).

### 4.3 Repository & Unit‑of‑Work Patterns

```ts
// domain/repositories/IQuizRepository.ts
export interface IQuizRepository {
  findActiveSession(userId: UserId): Promise<QuizSession | null>
  save(session: QuizSession): Promise<void>
}

// infra/unit-of-work.ts
export const withTransaction = db.transaction;
```

*Handlers* obtain a repository **through the Unit‑of‑Work closure**, ensuring every DB operation participates in the same transaction.

### 4.4 Slice Handler Example

```ts
import { withTransaction } from '@/infra/unit-of-work.ts'
import { DrizzleQuizRepository } from '../domain/repositories/DrizzleQuizRepository.ts'

export async function handle(cmd: StartQuizCommand) {
  return withTransaction(async trx => {
    const repo = new DrizzleQuizRepository(trx)
    // domain logic ...
  })
}
```

---

## 5 — Implementation Roadmap (Small‑Project Optimisation)

| Day         | Focus                  | Deliverables                                                                                                                                        |
| ----------- | ---------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Day 1**   | Minimal infrastructure | • Database connection wrapper<br>• Centralised error handling<br>• Core middlewares (logging, request‑ID, CORS)                                     |
| **Day 2‑3** | First vertical slice   | Implement **auth/login** *or* **quiz/start‑quiz** without domain model; validate request flow, use `withTransaction` helper, confirm JSON responses |
| **Day 4+**  | Incremental slices     | Gradually add quiz flow (start → submit → results), introduce domain model & repositories as business rules emerge                                  |

---

## 6 — Key Design Decisions — Key Design Decisions

|  Decision                           | Rationale                                                                                       |
| ----------------------------------- | ----------------------------------------------------------------------------------------------- |
| **Keep thin Repository interfaces** | Shields domain from Drizzle, eases DB swap/testing, but stays lightweight (no over‑abstraction) |
| **No explicit CQRS for now**        | Simpler; we can project read models later if needed                                             |
| **Unit‑of‑Work via closure**        | Leverages Drizzle’s `transaction()` without separate UoW class                                  |
| **Per‑slice co‑location**           | VSA principle; zero cross‑slice imports enforced by ESLint boundaries                           |
| **Evolutionary Domain Model**       | Start simple, introduce Aggregates/VOs when rules demand                                        |

---

## 7 — Testing Strategy

1. **Domain unit tests** – pure JS, 90% coverage goal.
2. **Repository tests** – run against SQLite in‑memory using Drizzle adapter.
3. **Slice contract tests** – Hono server boots, superoak requests.
4. **Smoke tests** – basic HTTP checks in CI.

---

## 8 — Cross‑Cutting Concerns

* **AuthZ/AuthN**: `withAuth()` HOF wraps protected handlers.
* **Observability**: structured pino logs, request IDs, OpenTelemetry exporter.
* **Error handling**: `ProblemDetails` JSON envelope, centralized middleware.

---

## 9 — Risks & Mitigations

| Risk                        | Mitigation                                           |
| --------------------------- | ---------------------------------------------------- |
| Schema drift during rewrite | Automated migration diff + nightly integration tests |
| Rewrite takes too long      | Phase releases behind feature flags                  |
| Team unfamiliar with VSA    | Kick‑off workshop + code review templates            |

---

## 10 — Definition of Done (per slice)

* Domain logic complete & tested
* Handler returns expected HTTP codes
* Repository implementation covered by tests
* API contract documented in OpenAPI spec
* ESLint boundaries check passes

---

## 11 — Rollout Phases

1. **Health & Observability**
2. **Read‑only quiz catalogue**
3. **Quiz session flow** (start → submit → results)
4. **User / Auth**
5. **Admin & analytics**

Each phase guarded by LaunchDarkly feature flag to enable gradual traffic.

---

## 12 — Enforcement Tooling

* `eslint-plugin-boundaries` for slice isolation.
* Husky + lint‑staged to run tests & lints pre‑commit.
* CI pipeline: type‑check → unit tests → contract tests → security scan.

---

## 13 — Next Steps

1. Seek team sign‑off on this plan.
2. Freeze legacy branch.
3. Scaffold new directory structure via Yeoman generator.
4. Implement `unit-of-work.ts` + health slice.
5. Configure CI/CD with new folder layout.

---

## 14 — Success Criteria

* All core features rebuilt on new stack
* ≥80 % overall test coverage (≥90 % domain)
* No cross‑slice import violations
* P95 latency equal to or better than legacy
* Zero‑downtime migration validated by parity tests

*Last Updated: 2025‑07‑07*
*Status: Planning Phase*
*Next Review: after Health slice merge*
